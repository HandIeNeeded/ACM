1. 不能交CE，尽量减少罚时
2. 数据范围注意不能爆int，或者LL（有取模尽量每步都取，应该不会TLE）（BZOJ1257再爆一次int）。
3. 图论问题一定要注意重边的bug，题目没说就一定要考虑。
4. 宏定义不要用错。
5. 计算几何，枚举角度，或者模拟退火，或者随机算法。
6. 本地测试算法效率，不要乱提交，用check.sh对拍。
7. 不要忘记打表，找规律，二分答案，暴力搜索。
8. 函数的返回值不要忘记。
9. 数字，字母不要打错，（sx，sy打成ex，ey，6打成7这种）总之就是SB错误不要犯。
10. 初始化一些值一定要小心，L=INF，R=-1之类。
11. spfa的vis数组表示的是状态是否在队列里面，而状态的最优值不能直接放到队列里，而是保存在dp数组里面，更新的时候用状态对应的dp值（最优解去更新），另外不要忘记消除出队标记。
12. spfa真的有卡的，要加优化。
13. bfs,spfa这种题目，把最初的状态放入队列的时候要注意赋这个状态的初值。并且把vis数组进行标记，bfs的vis表示访问过了，spfa表示当前在队列里。
14. 关于一些题目无解的情况一定要注意，只要一个无解就是无解还是所有无解才算无解。一般求最小值用INF表示无解，求最大值，用-1表示无解。
15. 网格图spfa要加优化，如果权值大于队首放队尾，否则放队首。
16. 地图看清楚题目是给的0base还是1base。
17. RI(x); 忘记存入数组了，a[i] = x;
18. deque写spfa的优化，和队首比较的时候先判断一下队列是不是空的。
19. 变量不要开成同样名字的。
20. 单调队列，不要忘记break，另外，加入队列的时候用本身的可选的点取维护凸性，求dp值的时候用dp的位置去维护凸性，两个都不能少。
21. CF220Div2 D，数列经过了树状数组修改，存在的数字已经减少了，但是询问是对没有修改前说的，所以每次要修改询问的大小，这个不要忘记。
22. 线段树build的时候就要考虑把所有需要维护的值都清空或者赋初值，千万不要忘记lazy要清空这种小错误。
23. 看到最大值最小，最小值最大就先二分.
24. 数组不要忘记清空。
25. 贪心方案比较，看直觉，我们比较相同步数，或者相同距离（花费等）情况下，哪种方案更优。例如Frog（HDU5037），如果我们要调整前面的步骤让青蛙跳到原有的石头上，那么前面的步数没有变多，但是却让青蛙走的更远，显然不优。
26. ***dp[i][j] = dp[i - 1][j];*** //保证dp取了之前所有结果的最优值，dp[i][j] = max(dp[i][j], dp[i - 1]][j - 1] + a[i] - a[i - m]);
27. 有些奇怪的题目，线段树的下标范围不是1-n，这里自己要注意。（HDOJ4267）
28. 热身赛先测栈大小，测c++11标准，测试printf的lf和f问题，打头文件，改codeblocks配置。
29. priority_queue<int> q; 没有迭代器。
30. 后缀数组需要特判长度n==1。
31. 数组名不能开next，jj。
32. 后缀数组，每个字符串末尾加一个比所有出现字符还小的字符（or数字 > 0），不需要初始化数组（都已经写在函数里面了）。
33. 回文子串的长度不具有二分性，比如不存在长度2的回文，但是可能存在长度3的回文，但是我们注意到，如果全是偶数，或者全是奇数就存在二分性了，所以我们可以分两个情况来讨论，奇偶性都二分总长的一般，这样就能二分解决了。
34. even > odd 和 2 * even > 2 * odd - 1 不等价，应该是even >= odd。（Ural 1297，这题要用rank数组）
35. KMP可以做一个串的重复子串表示，a=b^n，如果b存在，那么n-fail[n] = len(b)。所以只需要判断一下，n-fail[n]是否能被n整除。(POJ 2406),这题也可以后缀数组，或者暴力（枚举因子，暴力匹配）。
36. KMP的fail函数的意义还是很多的，值得思考。
37. 后缀数组的SA.n 和 n不能混用，不要轻易忘记。可以在函数里面引用。
38. 给一个序列，让你找另外一个序列来最优化一个啥的题目，一般两种思路，贪心，就是考虑相邻的两个谁放前面，然后算出花费，决定，另一种就是直接把总的表达式写出来，看看有什么规律，然后整体地考虑如何最优化。(比如CF的那个树上距离，用lcp把表达式写出来之后就是用树重心去贪心匹配)
39. cin 和 scanf什么不要混用。
40. bitset从右往左数。
41. 学会用__builtin_popcount()。
42. 如果要求很多次相同数字的bitcount（1的个数），数字范围数组又开不下，（比如范围是unsigned int），可以开1<<16大小的数组，然后算出结果，然后unsigned int拆成两部分算，这样也是要比每次__builtin_popcount()快的。
43. 数组下标的计算要小心，算一个数所在的块，如果是0base，直接除以块长即可。
44. __builtin_popcount()确实比手写的快，但是不明显，数据量到1e7，差距才1ms。
45. 查看运行时间：clock_t st = clock(), ed; //execute// ed = clock(); printf("%.10f\n", 1.0 * (ed - st) / CLOCKS_PER_SEC);
46. 并查集不要忘记初始化。
47. REP(i, n)里面不要再有变量是 REP(i, n)了。
48. 数论里面分块，直接从除数去考虑。（也可能是余数）。
49. 后缀数组所有加入的新字符（作为分隔符，和结尾符的字符，这种时候最好转化成int）要比原来有的字符小，而且都不相同。(POJ 3294)
50. 后缀数组计数，一个字符串的不同子串的个数是sigma {n - sa[i] - height[i]}。
51. 打印结果，LL的不要逗比地用%d，（NEERC2011，H）
52. Merge_Sort()，用数组实现，应该一个一个递归。而不是一次递归两个。
53. spfa进队忘记加标记了，导致所有状态很多次加入队列，标记应该在最后清空，如果前面就清空，这个状态很可能又被加入队列了。
54. 强迫症不要太严重，如果是dp记录最小值，那么一开始就memm成INF，如果是求最大值一开始就memm成-1，然后转移就不用特判啦。
55. spfa的优化，不要忘记判断SZ(deque)是不是0。
56. SRM629 A串变成B串，每次只能把A的某个字符放到A的最前面，最少几步？逆向考虑，B怎么变成A，就是B的最前面的字母任意插入B的一个位置。注意由于这个操作的任意性，前后顺序没有关系。所以就相当于B的前x位任意往后插，变成A。所以要求B的后缀是A的子序列。所以暴力匹配一下，最长能匹配几个后缀就好了。
57. 线段树，如果是自己建的序列上做线段树（比如欧拉序列上搞），不要忘记把读入的数据转化成对应的序列上的数，而不是直接用那个数去询问，因为并不是x就是你的序列上的x。CF396C
58. 防止比赛的时候没有好用的等宽字体，ubuntu一般都有的一个字体是D。
59. abs()返回值是int类型，再乘以一个数可能会爆int。
60. 线段树区间维护是不是同一种颜色，每次update都得记得维护是不是同一种颜色。即在最后加一句，col[x] = col[L] == col[R] ? col[L] : 0; CF444C。
61. %d %o %x %X分别是 十进制，八进制，十六进制（小写），十六进制（大写）的输出格式。
62. AC自动机，fail函数直接一步转移，即把不存在的边补上，不要写跳转，会有很多问题。
63. 需要取第一个满足条件的变量，遇到就更新，但是需要一个flag，表示已经遇到，否则之后还会更新，就错过了最早的一个。
64. 关于gcd，如果a！= b,且a<b，那么gcd（a,b）<= b/2,区间gcd不同的值最多log段，CF #270 D
65. 线段树叶子节点没有L和R，注意!!!
66. m < 2^31，m+1可能爆int，注意！！！
67. AC自动机的val如果表示根到这个节点的路径上是否包含某些单词，那么除了沿trie的树边传val，一定还要记得沿fail传val。
68. 堆排序先makeheap，从1/2处到1做maxheapfy，然后swap n-1次首尾，注意每swap一次，节点总数减少1。
69. 基数排序，统计好个数之后，是倒着放，否则位置是反的。
70. 行列这种对称的东西，一般手打，不要复制，万一就复制错了。找错找半天。
71. 要记得一些细节的bug，比如判第一个字母是不是大写，_的下一个字符是不是_，NEERC06J
72. dp有好多层的时候，一个需要注意的问题就是是否需要利用上一层的结果。如果需要，那么就必须先把这层的dp值设置成上层的值，然后dp转移的时候再更新。（SRM502 500）
73. 有一些染色覆盖操作，对整行整列进行，那么一次操作就可以抹消之前所有的操作，这种东西性质不错。所以如果有询问，那么只需要找到这一行最后一次被操作的时间，然后从这个时间点开始的操作才有效果。之后可以用树状数组什么的搞。叉姐训练第一场，C。这题就是这种操作，行列同时变成0或者1，然后询问某行或某列0的个数。因此对于一个行询问，询问行row[i]，只需要记下，他的最后一次操作，lastrow[i]，那么之后只有列操作会改变这行的状态。首先这里要注意的就是lastrow是把这行修改成0还是1，如果是0，那么就要统计之后的对列进行设置成1的操作的个数，答案是n-这个数，如果是设置成1，那么统计之后的对列设置成0的操作的，答案就是这个数。这里统计的时候还有一些细节，就是可能某一列先被设置成了0，然后又被设置成了1，我们首先用4个树状数组存信息，两个行，两个列，两个表示设置成0的操作，两个设置成1，那么如果时间i的时候某行被设置成了0，那么就在表示0的行树状数组上的i位置加1，同时如果表示1的行树状数组的i位置是1，那么需要减掉这个设置成1的效果，因为这个行设置成1的操作已经被后来的抹消了效果，没有意义了。最后就只要统计所有有意义的操作就好了。比如行2在1时间，被设成0，之后时间2设置列3，设成1，再时间3设置列3，设成0，然后时间4询问行2，那么就是2-4的时间内，把列设置成1的有效操作的个数，第一个设置列3成0的列操作，被加到列操作上，但是后来来了设置列3，1的操作，前一个操作必须取消，然后在表示列设置1的树状数组上加入。（这是因为，询问总是对当前的时间的状态的询问，我们跟着询问做，做到的总是目前的状态，所以直接改掉没关系。这里自己体会）这种题目行列看着就很对称，但是写代码的时候还是不要偷懒copy代码。因为本来代码就不难写，你能写一个出来，就能写第二个，只是做一些小改动，但是copy很可能出错，WA了就不值得了。而且查起来费时间。
74. 拓扑排序，时间复杂度O(m)（邻接表存关系，这需要处理重边，自环注意一下！），用一个栈保存当前所有度为0的即可，注意每个处理过的度为0的点要标记起来，下次新的度为0的点去更新的时候不能更新到这些点，否则可能度就有负数了，出现各种奇怪的东西？然后所有和拓扑序有关的字典序全部倒着做。也就是拓扑序的逆序去分配字典序。先分配大的。这样才是正确的。否则直接按拓扑序是错的！（POJ3687，叉姐训练#2B）
75. 看清题目，是选一些数，之后排序，还是选的是原来的子序列，相对顺序不能改变。sort下标的话，要记得tmp[i] = i,先赋值，和并查集类似。
76. 两个字符串排在一起，使得答案尽可能大，直接cmp,a+b和b+a的大小关系。而不是把短的补到和大的一样长然后比较。反例A = abcab，B=abc，那么如果补B的话，变成abcab，和A一样，事实上却是A要在前面，因为A+B>B+A(Children's Game)
77. 沙漏路径，UVA10564，要保证起始点最小，首先做dp，一个保存方案书，一个保存能到这个点的起始点的最小值。然后知道了起始点最小值之后，在做一次dp，这时候dp字典序最小的串，这里要注意，第一行的状态只把起始点最小的点加进去。其他点都不能加，因为可能会有起始点更大，但是字典序更小的串。就会错了。
78. 一个字符串的回文子串的个数统计，或者求最长的回文自创都可以通过区间dp实现。最外层循环长度，里面循环左边的位置。时间复杂度O（N^2）.
79. 求旋转角，atan2（det（a，b），dot（a，b）），a，b表示原向量和旋转后的向量。
80. 容斥原理只要用到质数，和质数相乘的结果，所有数字里面质数的次数不会大于1，dfs的过程很枚举因子略有不同。
81. 数学公式题，一边可以考虑用快速幂的思想递降，ｎ为奇，直接n-1来算n，否则调n/2.然后注意把结果记忆化，能加快速度，否则可能TLE，HankRanker 数学比赛８，blackhole.
sum = 1ll * x  * y + z * w有可能爆int.
82. for i in `seq 100`; do ./make > tmp${i}; done  shell 调用make100次生成100个tmpi文件
83. dp的时候可以先要用的数字先排序,(如果整个dp和数字的大小有关的话),然后尝试按一定顺序(小到大or大到小),这样能更好地转移,或者发现性质.叉姐训练#4 A.
84. 容斥原理,求1-n中是任意一个ai的倍数的个数的,那么odd为1的时候减,odd为0的时候是加,那么求出来的是不是ai的倍数的数,所以n-ans就是我们要求的,这样就不用特判now==1的情况啦.统一且整齐.然后如果求是4,和6的倍数的数,就是4的倍数+6的倍数-12的倍数,这里就是lcm,所以求lcm可能会爆int或者LL,因此一定要在now要乘以a[dep]的时候用除法判断是否大于上界x了.(HankRanker 数学比赛８，Mehta and the Typical Supermarket.),这里还有一个优化就是先把所有是其他数的倍数的数去掉.
85. 进制转化的时候一定要注意，base不能等于1，否则就死循环了，还有就是digit=0，（2014NEERC Sub Moscow E），这些都特判掉，最好n==1和n==d也特判。
86. 判一棵树能否分成不相交的k个联通块，每块m就看边的条数，（一条边把树分成2部分，如果每部分点数都是m的倍数，是则满足），最好看这个边的条数是否是k-1.（每个块看成一个的点，需要k-1条边）
87. 最大流最小割输出割边，直接利用最后bfs剩下的图，lvl==0的点是T集合，其他是S集合，Dinic的bfs不要忘记给source进队的时候打上标记。
90. 搜索的时候，有些函数里面要对一个数组进行修改，之后又还需要用，就得先copy，然后复原，拷贝的数组有时候必须是局部变量开在函数里面。
91. 有向边是唯一的，但是无向边就不是唯一的了，有两种表示，xy和yx，所以如果要用map或者set记一个边的话，记得先通过swap保证x<y.
92. 联通块向4or6个方向拓展，需要检查是否出界了（0-n-1），否则根本停不下来，RE。(SRM638 300)
93. 有些奇怪的关系总是能最后转化成进制数！比如2014 NEERC_Sub_Moscow I 猜质数，以及构造两两不同的字符串，有k个字符就是k进制。
94. __builtin_popcount()只是算int的1个个数，LL不是这个，随意以后还是手写吧。
95. 找a[i] % a[j]的最大值(a[i] >= a[j])，分块，对于所有<= sqrt的a[j],，所有数字mod他做一遍，大于sqrt的数字，那么商最多sqrt种，枚举商，现在就是要在区间kx-（k+1）x里面找最大的出现过的数字，直接预处理，用一个数组l[i]保存i及i之前出现的最大数字，从左往右dp一遍就可以做出来了。
96. 做因式分解的时候，把原来的数字保存一份，或者用tmp来做，每次除去因子，不要直接用原来的数字，否则原来的n就只剩1了。
97. sort的比较函数必须是严格的偏序，所以不能写<=这种符号，尽量都不要用，用<就可以了。
98. add做取模的加法，首先要保证add的两个数都是比MOD小的，不要负数。否则会出问题。
99. 线段树，push到底的更新，要注意有没有叶子节点，这个push怎么写，另外更新的时候的区间整个被包含了，但是不是统一的颜色或者数字， 那么继续更新，这时候要注意一些细节，不能想当然，比如说，只更新比qx大的数字，那么首先得判断是不是区间的标记比qx大，如果大更新，如果不是，什么也不做，注意这里不能直接进入下一个else，而是什么都不做，因为这里的区间标记是存在的，不存在才是进入else！
100. 有一类看似数位dp的题目，实际上是暴力，比如只包含2,5,8的数字，在int范围内并不多，\sum3^i = (3^10-1)/2,我们可以预处理出一个表，然后直接在表上一段一段计算。我们会求不超过n的这种特殊数字的和，却不会求大于n的最小的数字的和。这其实是可以暴力的。USTCOJ Ugly Numbers。
101. cmp函数的返回值是int，不要SB开成bool。
102. 0base到计数，前一半是0-n/2（不包括n/2），后一半是n/2-n-1，奇数的时候n/2是中间值，偶数的时候n/2是属于后一半的。CF#278Div2C
103.AC自动机的初始化不能只MST(tr[node], 0), 还要记得把fail[node], val[node]等所有和这个节点相关的信息清空.AC自动机,getfail, int &y = tr[x][i]; !y, y = tr[fail[x]][i]; y, fail[y] = tr[fail[x]][i];
104.过早优化做大死.
105.不要忘记修改要修改的值.add如果不是引用,就得手动修改,c=add(a,b);
106.顶点在格点的正n边形只有正方形.
107.
独立集：
    独立集是指图的顶点集的一个子集,该子集的导出子图不含边.如果一个独立集不是任何一个独立集的子集, 那么称这个独立集是一个极大独立集.一个图中包含顶点数目最多的独立集称为最大独立集。最大独立集 一定是极大独立集，但是极大独立集不一定是最大的独立集。

支配集：

    与独立集相对应的就是支配集，支配集也是图顶点集的一个子集，设S 是图G 的一个支配集，则对于图中的任意一个顶点u，要么属于集合s, 要么与s 中的顶点相邻。 在s中除去任何元素后s不再是支配集，则支配集s是极小支配集。称G的所有支配集中顶点个数最 少的支配集为最小支配集，最小支配集中的顶点个数成为支配数。

最小点的覆盖：

    最小点的覆盖也是图的顶点集的一个子集，如果我们选中一个点，则称这个点将以他为端点的所有边都覆盖了。将图中所有的边都覆盖所用顶点数最少，这个集合就是最小的点的覆盖。

最大团：

    图G的顶点的子集，设D是最大团，则D中任意两点相邻。若u，v是最大团，则u,v有边相连，其补图u,v没有边相连，所以图G的最大团=其补图的最大独立集。

一些性质：

最大独立集+最小覆盖集=V

最大团=补图的最大独立集

最小覆盖集=最大匹配
108.

数学知识：

欧拉常数：0.577215664901532860606512090082402431042
mobius[N] = {0, 1};//0, 1，实际上只对正整数定义，所以只记住mobius(1)=1即可。
Fibonacci数列Mod N的循环节，看N的质因子p是不是5的二次剩余，是，循环节是N-1的因子，不是，循环节是2(N+1)的因子，然后p^k -> G(p)*p^(k-1)，对所有p求出来，求公倍数
1e9以内的数的约数个数规模1000,1e18对应的是100000。
1e9以内不超过N的质数的个数可以用N/10近似。
1e9以内质数差距最大不超过200。
二项式反演：a_n = \sum_{k = 1}^{n}{C_{n}^{k}*b_k}   b_n = \sum_{k=1}^{n}{(-1)^{n - k} * C_{n}^{k} * a_k}。
梅森素数：
int p[48] = {2, 3, 5, 7, 13, 17, 19, 31, 61, 89, 107, 127, 521, 607, 1279, 
	2203, 2281, 3217, 4253, 4423, 9689, 9941, 11213, 19937, 21701, 
	23209, 44497, 86243, 110503, 132049, 216091, 756839, 859433, 
	1257787, 1398269, 2976221, 3021377, 6972593, 13466917,20996011, 
	24036583, 25964951, 30402457, 32582657, 37156667, 42643801, 43112609, 57885161 
};
平方求和公式：n*(n+1)*(2*n+1)/6。
三次方求和公式：n*n*(n+1)*(n+1)/4。
四次方求和公式：n*(n+1)*(2*n+1)*(3*n*n+3*n-1)/30。
五次方求和公式：n*n*(n+1)*(n+1)*(2*n*n+2*n-1)/12。
拉格朗日四平方和定理：(a^2+b^2+c^2+d^2)(x^2+y^2+z^2+w^2) = (ax+by+cz+dw)^2+(ay-bx+cw-dz)^2+(az-bw-cx+dy)^2+(aw+bz-cy-dx)^2


